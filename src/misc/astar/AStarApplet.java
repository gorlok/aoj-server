package misc.astar;import java.applet.*;import java.awt.*;import java.awt.event.*;import java.util.Vector;public class AStarApplet extends Applet implements MouseListener, MouseMotionListener {	private static final long serialVersionUID = 1L;	static final int appletWidth = 601, appletHeight = 401, gridWidth = appletHeight,                     numRows = 20;        static final int cellWidth = gridWidth / numRows;                         static final int pad = 10;    static int current = Constants.NOTHING, startI = Constants.NOTHING, startJ = Constants.NOTHING, finishI = Constants.NOTHING,               finishJ = Constants.NOTHING;        static Color[] tColor = new Color[Constants.NUMCOLORS];        static int[][] grid = new int[numRows][numRows];    static int[] costs = new int[Constants.NUMCOLORS];    static Graphics g;        @Override	public void init() {        g = getGraphics();        resize(appletWidth, appletHeight);        tColor[Constants.EMPTY] = Color.black;        costs[Constants.EMPTY] = 1;        tColor[Constants.TERRAIN1] = new Color(0, 88, 0);        costs[Constants.TERRAIN1] = 5;        tColor[Constants.TERRAIN2] = new Color(99, 77, 0);        costs[Constants.TERRAIN2] = 10;        tColor[Constants.TERRAIN3] = Color.blue;        costs[Constants.TERRAIN3] = 15;        tColor[Constants.SOLID] = Color.white;        costs[Constants.SOLID] = Constants.NOTHING;        tColor[Constants.START] = Color.green;        costs[Constants.START] = 1;        tColor[Constants.FINISH] = Color.red;        costs[Constants.FINISH] = 1;        addMouseListener(this);        addMouseMotionListener(this);    }        @Override	public void start() {        paint(getGraphics());    }        @Override	public void stop() {    	//    }            @Override	public void paint(Graphics g) {        g.setColor(Color.black);        g.fillRect(0, 0, appletWidth, appletHeight);        drawAll();    }        @Override	public void update(Graphics g) {        paint(g);    }        private void drawAll() {        for(int i = 0; i < numRows; i++) {            for(int j = 0; j < numRows; j++) {                drawCell(i, j);            }        }        if(startI != Constants.NOTHING) {            drawCell(startI, startJ);        }        if(finishI != Constants.NOTHING) {            drawCell(finishI, finishJ);        }        int left = gridWidth + pad;        for(int i = Constants.EMPTY; i <= Constants.FINISH; i++) {            int top = pad + (cellWidth + pad) * i;            drawTerrainButton(i, left, top, (current == i ? true : false));        }        drawButtons();    }        int buttonsLeft = gridWidth + pad * 2;    int buttonsWidth = appletWidth - gridWidth - pad * 4;    int buttonsHeight = 20;    int goTop = appletHeight - pad - (this.buttonsHeight + pad) * 2;    int clearTop = appletHeight - pad - (this.buttonsHeight + pad);        private void drawButtons() {        int halfWidth = this.buttonsLeft + this.buttonsWidth / 2;        String goString = "GO", clearString = "CLEAR PATH";        g.setColor(Color.white);        g.drawRect(this.buttonsLeft, this.goTop, this.buttonsWidth, this.buttonsHeight);        g.drawRect(this.buttonsLeft, this.clearTop, this.buttonsWidth, this.buttonsHeight);        g.setFont(new Font("SansSerif", Font.BOLD, 12));        g.drawString(goString, halfWidth - g.getFontMetrics().stringWidth(goString) / 2, this.goTop + 15);        g.drawString(clearString, halfWidth - g.getFontMetrics().stringWidth(clearString) / 2, this.clearTop + 15);    }        private void drawCell(int i, int j) {        int left = i * cellWidth, top = j * cellWidth;        g.setColor(Color.lightGray);        g.drawRect(left, top, cellWidth, cellWidth);        if(grid[i][j] == Constants.START) {            g.setColor(tColor[Constants.START]);            g.drawRect(left, top, cellWidth, cellWidth);            g.setColor(Color.black);            g.fillRect(left + 1, top + 1, cellWidth - 1, cellWidth - 1);        } else if(grid[i][j] == Constants.FINISH) {            g.setColor(tColor[Constants.FINISH]);            g.drawRect(left, top, cellWidth, cellWidth);            g.setColor(Color.black);            g.fillRect(left + 1, top + 1, cellWidth - 1, cellWidth - 1);        } else if(grid[i][j] == Constants.NOTHING) {            g.setColor(Color.black);            g.fillRect(left + 1, top + 1, cellWidth - 1, cellWidth - 1);        } else {            g.setColor(tColor[grid[i][j]]);            g.fillRect(left + 1, top + 1, cellWidth - 1, cellWidth - 1);        }    }        private void drawTerrainButton(int i, int left, int top, boolean on) {        g.setFont(new Font("SansSerif", Font.BOLD, 12));        if(i == Constants.START || i == Constants.FINISH) {            g.setColor(tColor[i]);            g.drawRect(left, top, cellWidth, cellWidth);            g.setColor(Color.white);            if(i == Constants.START) {                g.drawString("START",left + cellWidth + pad * 2, top + cellWidth);            } else if(i == Constants.FINISH) {                g.drawString("FINISH",left + cellWidth + pad * 2, top + cellWidth);            }        } else {            g.setColor(tColor[i]);            g.fillRect(left, top, cellWidth, cellWidth);            g.setColor(Color.white);            g.drawRect(left, top, cellWidth, cellWidth);            g.setColor(Color.white);            g.drawString((i == Constants.SOLID ? "SOLID" : String.valueOf(costs[i])),left + cellWidth + pad * 2, top + cellWidth);        }        if(on) {            g.setColor(Color.red);        } else {            g.setColor(Color.black);        }        g.fillRect(left + cellWidth + pad / 2, top, pad / 2, cellWidth + 1);    }        /*    private void drawStartStop(int i, int left, int top, boolean on) {        if(on) {            g.setColor(Color.red);        } else {            g.setColor(Color.black);        }        g.fillRect(left + cellWidth + pad / 2, top, pad / 2, cellWidth + 1);    }    */        public void mouseClicked(MouseEvent e) {    	//    }    public void mousePressed(MouseEvent e) {        int x = e.getX(), y = e.getY();                if(x < gridWidth - 1) {            checkGrid(x, y);        } else {            int left = gridWidth + pad;            int old = current;            boolean selected = false;            for(int i = Constants.EMPTY; i <= Constants.FINISH; i++) {                int top = pad + (cellWidth + pad) * i;                if(checkBounds(left, top, cellWidth, cellWidth, x, y)) {                    drawTerrainButton(current = i, left, top, true);                    selected = true;                    break;                }            }            if(!selected) {                current = Constants.NOTHING;                if(checkBounds(this.buttonsLeft, this.goTop, this.buttonsWidth, this.buttonsHeight, x, y) && startI != Constants.NOTHING && finishI != Constants.NOTHING) {                    AStar a = new AStar(grid, costs, new Location(startI, startJ), new Location(finishI, finishJ));                    Vector<Node> solution = a.AStarSearch(null);                    if(solution != null) {                        g.setFont(new Font("SansSerif", Font.BOLD, 12));                        for(int i = 0; i < solution.size(); i++) {                            Location nodeLoc = (solution.elementAt(i)).location;                            drawDot(nodeLoc.x, nodeLoc.y);                            try {                                Thread.sleep(300);                            } catch(InterruptedException ex) {                            	//                            }                        }                    }                } else if(checkBounds(this.buttonsLeft, this.clearTop, this.buttonsWidth, this.buttonsHeight, x, y)) {                    drawAll();                }            }            if(old != current) {                drawTerrainButton(old, left, pad + (cellWidth + pad) * old, false);            }        }    }            public void mouseDragged(MouseEvent e) {        int x = e.getX(), y = e.getY();                checkGrid(x, y);    }        private void checkGrid(int x, int y) {        if(x < gridWidth - 1) {            if(current != Constants.NOTHING) {                int i = x / numRows, j = y / numRows;                if(grid[i][j] == Constants.START) {                    startI = finishJ = Constants.EMPTY;                }                if(grid[i][j] == Constants.FINISH) {                    finishI = finishJ = Constants.EMPTY;                }                if(current == Constants.START) {                    if(startI != Constants.NOTHING) {                        grid[startI][startJ] = Constants.EMPTY;                        drawCell(startI, startJ);                    }                    startI = i;                    startJ = j;                } else if(current == Constants.FINISH) {                    if(finishI != Constants.NOTHING) {                        grid[finishI][finishJ] = Constants.EMPTY;                        drawCell(finishI, finishJ);                    }                    finishI = i;                    finishJ = j;                }                grid[i][j] = current;                drawCell(i, j);            }        }    }        public void mouseMoved(MouseEvent e) {    	//    }        private void drawDot(int i, int j) {        int left = i * cellWidth + 1, top = j * cellWidth + 1, right = left + cellWidth - 2, bottom = top + cellWidth - 2;        g.setColor(Color.yellow);        g.drawLine(left + cellWidth / 2 - 1, top, right, top + cellWidth / 2 - 1);        g.drawLine(right, top + cellWidth / 2 - 1, left + cellWidth / 2 - 1, bottom);        g.drawLine(left + cellWidth / 2 - 1, bottom, left, top + cellWidth / 2 - 1);        g.drawLine(left, top + cellWidth / 2 - 1, left + cellWidth / 2 - 1, top);    }        public void mouseReleased(MouseEvent e) {    	//    }        public void mouseEntered(MouseEvent e) {    	//    }    public void mouseExited(MouseEvent e) {    	//    }       private boolean checkBounds(int left, int top, int buttonWidth, int buttonHeight, int x, int y) {        return (x >= left && x < left + buttonWidth && y >= top && y < top + buttonHeight);    }}